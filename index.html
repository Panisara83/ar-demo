<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <title>Markerless AR Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <style>
    body { margin:0; overflow:hidden; }
    #hint {
      position: absolute; left: 8px; right:8px; bottom: 12px;
      background: rgba(0,0,0,0.6); color: #fff; padding:10px;
      border-radius:8px; text-align:center; z-index: 10;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="hint">แตะหน้าจอเพื่อวางกล่อง 3D • หนีบ/หมุนด้วยสองนิ้ว • ลากหนึ่งนิ้วเพื่อหมุน</div>

  <a-scene embedded webxr="optionalFeatures: hit-test, local-floor;">
    <a-entity id="cameraRig">
      <a-camera id="camera"></a-camera>
    </a-entity>

    <!-- โมเดลกล่อง -->
    <a-entity id="modelRoot" visible="false" position="0 0 -1" scale="0.5 0.5 0.5">
      <a-box id="boxModel" color="#4CC3D9" depth="0.5" height="0.5" width="0.5"></a-box>
    </a-entity>
  </a-scene>

  <script>
    const scene = document.querySelector('a-scene');
    const cameraEl = document.getElementById('camera');
    const modelRoot = document.getElementById('modelRoot');
    let placed = false;

    scene.addEventListener('click', () => {
      if (!placed) {
        placeModelInFront();
        placed = true;
        modelRoot.setAttribute('visible', 'true');
      }
    });

    function placeModelInFront() {
      const camObj = cameraEl.object3D;
      const worldPos = new THREE.Vector3();
      const worldDir = new THREE.Vector3(0,0,-1);
      camObj.getWorldPosition(worldPos);
      camObj.getWorldDirection(worldDir);
      const targetPos = worldPos.clone().add(worldDir.multiplyScalar(1));
      targetPos.y = worldPos.y - 0.5;
      modelRoot.object3D.position.copy(targetPos);
    }

    // Gesture ลากหมุน + pinch ซูม
    let ongoing = {mode:null, startScale:1, startRotY:0, lastX:0, startDist:0};

    function dist(t1,t2){return Math.hypot(t1.clientX-t2.clientX,t1.clientY-t2.clientY);}
    function angle(t1,t2){return Math.atan2(t2.clientY-t1.clientY,t2.clientX-t1.clientX)*180/Math.PI;}

    window.addEventListener('touchstart',(e)=>{
      if(!placed) return;
      if(e.touches.length===1){
        ongoing.mode='one';
        ongoing.lastX=e.touches[0].clientX;
        ongoing.startRotY=modelRoot.getAttribute('rotation').y;
      } else if(e.touches.length===2){
        ongoing.mode='two';
        ongoing.startDist=dist(e.touches[0],e.touches[1]);
        ongoing.startScale=modelRoot.getAttribute('scale').x;
        ongoing.startRotY=modelRoot.getAttribute('rotation').y;
        ongoing.startAngle=angle(e.touches[0],e.touches[1]);
      }
    },{passive:true});

    window.addEventListener('touchmove',(e)=>{
      if(!placed) return;
      e.preventDefault();
      if(ongoing.mode==='one'&&e.touches.length===1){
        const dx=e.touches[0].clientX-ongoing.lastX;
        modelRoot.setAttribute('rotation',{x:0,y:ongoing.startRotY-dx*0.3,z:0});
      } else if(ongoing.mode==='two'&&e.touches.length===2){
        const newDist=dist(e.touches[0],e.touches[1]);
        let scale=ongoing.startScale*(newDist/ongoing.startDist);
        scale=Math.min(Math.max(scale,0.1),3);
        modelRoot.setAttribute('scale',`${scale} ${scale} ${scale}`);
        const deltaAngle=angle(e.touches[0],e.touches[1])-ongoing.startAngle;
        modelRoot.setAttribute('rotation',{x:0,y:ongoing.startRotY-deltaAngle,z:0});
      }
    },{passive:false});

    window.addEventListener('touchend',()=>{ongoing.mode=null;});
    window.addEventListener('touchcancel',()=>{ongoing.mode=null;});
  </script>
</body>
</html>
