<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8">
  <title>Markerless AR Full Debug</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <style>
    body { margin:0; overflow:hidden; font-family:sans-serif; }
    #controls {
      position: absolute; top:10px; left:10px; z-index:10;
      display:flex; gap:8px; flex-wrap: wrap;
    }
    button {
      padding:6px 12px; border-radius:6px; border:none; background:#007bff; color:#fff; font-size:14px;
    }
    #hint {
      position:absolute; left:10px; right:10px; bottom:12px;
      background:rgba(0,0,0,0.6); color:#fff; padding:10px;
      border-radius:8px; text-align:center; font-size:14px; z-index:10;
    }
    #debugLog {
      position:absolute; top:50px; left:10px; max-height:200px; width:95%;
      overflow:auto; background:rgba(0,0,0,0.6); color:#0f0; padding:10px;
      border-radius:8px; font-family:monospace; font-size:12px; z-index:10;
    }
  </style>
</head>
<body>
  <div id="controls">
    <button id="startCam">‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á</button>
    <button id="stopCam">‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á</button>
    <button id="switchCam">‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á</button>
    <button id="checkDebug">Debug Status</button>
  </div>
  <div id="hint">‡πÅ‡∏ï‡∏∞‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ß‡∏≤‡∏á‡πÇ‡∏°‡πÄ‡∏î‡∏• ‚Ä¢ Pinch ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ç‡∏¢‡∏≤‡∏¢/‡∏´‡∏°‡∏∏‡∏ô‡∏™‡∏≠‡∏á‡∏ô‡∏¥‡πâ‡∏ß ‚Ä¢ ‡∏•‡∏≤‡∏Å‡∏ô‡∏¥‡πâ‡∏ß‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏°‡∏∏‡∏ô</div>
  <div id="debugLog">[Debug log]</div>

  <a-scene embedded webxr="optionalFeatures: hit-test, local-floor;">
    <a-entity id="cameraRig">
      <a-camera id="camera"></a-camera>
    </a-entity>

    <!-- ‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô -->
    <a-box id="model" color="#FF0000" depth="0.5" height="0.5" width="0.5"
           visible="true" position="0 0 -1"></a-box>

    <a-sky color="#222"></a-sky>
  </a-scene>

  <script>
    const logBox = document.getElementById("debugLog");
    function log(msg){ console.log(msg); logBox.textContent += "\n"+msg; }

    const cameraEl = document.getElementById('camera');
    const model = document.getElementById('model');
    const scene = document.querySelector('a-scene');
    let placed=false;
    let stream=null;
    let usingFrontCamera = false; // false = ‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏´‡∏•‡∏±‡∏á, true = ‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏´‡∏ô‡πâ‡∏≤

    // -------------------------
    // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á
    async function startCamera(front=false){
      if(stream){
        stream.getTracks().forEach(track=>track.stop());
      }
      const constraints = {
        video: { facingMode: front ? "user" : { exact: "environment" } }
      };
      try{
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        usingFrontCamera = front;
        log("‚úÖ ‡∏Å‡∏•‡πâ‡∏≠‡∏á "+(front?"‡∏´‡∏ô‡πâ‡∏≤":"‡∏´‡∏•‡∏±‡∏á")+" ‡πÄ‡∏õ‡∏¥‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à");
      }catch(e){
        log("‚ùå ‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: "+e.message);
      }
    }

    // -------------------------
    // ‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î/‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á
    document.getElementById("startCam").addEventListener("click", ()=>startCamera(usingFrontCamera));
    document.getElementById("stopCam").addEventListener("click", ()=>{
      if(stream){
        stream.getTracks().forEach(track=>track.stop());
        log("üõë ‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ñ‡∏π‡∏Å‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß");
        stream=null;
      }else log("‚ö†Ô∏è ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà");
    });
    document.getElementById("switchCam").addEventListener("click", ()=>{
      startCamera(!usingFrontCamera);
    });

    // -------------------------
    // ‡∏õ‡∏∏‡πà‡∏° debug
    document.getElementById("checkDebug").addEventListener("click", ()=>{
      log("---- DEBUG STATUS ----");
      log("üì∑ Camera active: "+(stream ? "Yes" : "No"));
      log("üü• Model visible: "+model.getAttribute("visible"));
      log("üîπ WebXR: "+(navigator.xr ? "Supported" : "Not Supported"));
    });

    // -------------------------
    // ‡∏ß‡∏≤‡∏á‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÅ‡∏ï‡∏∞
    scene.addEventListener("click", ()=>{
      if(!placed){
        placeModel();
        placed=true;
        log("üü• Model placed and visible");
      }
    });

    function placeModel(){
      const camObj = cameraEl.object3D;
      const worldPos = new THREE.Vector3();
      const worldDir = new THREE.Vector3(0,0,-1);
      camObj.getWorldPosition(worldPos);
      camObj.getWorldDirection(worldDir);
      const targetPos = worldPos.clone().add(worldDir.multiplyScalar(1));
      targetPos.y = worldPos.y-0.5;
      model.object3D.position.copy(targetPos);
    }

    // -------------------------
    // Gesture ‡∏´‡∏°‡∏∏‡∏ô/‡∏Ç‡∏¢‡∏≤‡∏¢
    let ongoing={mode:null,startScale:1,startRotY:0,lastX:0,startDist:0,startAngle:0};
    function dist(t1,t2){return Math.hypot(t1.clientX-t2.clientX,t1.clientY-t2.clientY);}
    function angle(t1,t2){return Math.atan2(t2.clientY-t1.clientY,t2.clientX-t1.clientX)*180/Math.PI;}

    window.addEventListener("touchstart",(e)=>{
      if(!placed) return;
      if(e.touches.length===1){
        ongoing.mode='one';
        ongoing.lastX=e.touches[0].clientX;
        ongoing.startRotY=model.getAttribute('rotation').y;
      }else if(e.touches.length===2){
        ongoing.mode='two';
        ongoing.startDist=dist(e.touches[0],e.touches[1]);
        ongoing.startScale=model.getAttribute('scale').x;
        ongoing.startRotY=model.getAttribute('rotation').y;
        ongoing.startAngle=angle(e.touches[0],e.touches[1]);
      }
    },{passive:true});

    window.addEventListener("touchmove",(e)=>{
      if(!placed) return;
      e.preventDefault();
      if(ongoing.mode==='one' && e.touches.length===1){
        const dx = e.touches[0].clientX - ongoing.lastX;
        model.setAttribute('rotation',{x:0,y:ongoing.startRotY - dx*0.3,z:0});
      }else if(ongoing.mode==='two' && e.touches.length===2){
        const newDist=dist(e.touches[0],e.touches[1]);
        let scale=ongoing.startScale*(newDist/ongoing.startDist);
        scale=Math.min(Math.max(scale,0.1),3);
        model.setAttribute('scale',`${scale} ${scale} ${scale}`);
        const deltaAngle=angle(e.touches[0],e.touches[1])-ongoing.startAngle;
        model.setAttribute('rotation',{x:0,y:ongoing.startRotY - deltaAngle,z:0});
      }
    },{passive:false});

    window.addEventListener("touchend",()=>{ongoing.mode=null;});
    window.addEventListener("touchcancel",()=>{ongoing.mode=null;});

  </script>
</body>
</html>
